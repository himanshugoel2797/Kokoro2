using Kokoro2.Math;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Kokoro2.Engine.HighLevel.Voxel
{
    public enum BinaryVoxelChunkLOD
    {
        LOD0 = 32,
        LOD1 = 64,
        LOD2 = 128
    }

    [ProtoContract]
    public class BinaryVoxelChunk
    {
        [ProtoMember(1)]
        public int ID;

        [ProtoMember(2)]
        public BinaryVoxelChunkLOD LoD;

        [ProtoMember(3)]
        public bool[,,] Present;
    }

    [ProtoContract]
    public class BinaryVoxelNode
    {
        [ProtoMember(1)]
        public int LOD0_ID;

        [ProtoMember(2)]
        public int LOD1_ID;

        [ProtoMember(3)]
        public int LOD2_ID;
    }

    [ProtoContract]
    public class BinaryVoxelTree
    {
        [ProtoMember(1)]
        public BinaryVoxelTree Front;

        [ProtoMember(2)]
        public BinaryVoxelTree Back;

        [ProtoMember(3)]
        public BinaryVoxelTree Left;

        [ProtoMember(4)]
        public BinaryVoxelTree Right;

        [ProtoMember(5)]
        public BinaryVoxelTree Top;

        [ProtoMember(6)]
        public BinaryVoxelTree Bottom;

        [ProtoMember(7)]
        public BinaryVoxelTree Center;

        [ProtoMember(8)]
        public BinaryVoxelNode Node;
    }

    [ProtoContract]
    public class VoxelObject
    {
        [ProtoMember(1)]
        public BinaryVoxelTree Center { get; set; }

        [ProtoMember(2)]
        private string BinaryVoxelChunk_LOD0_File;

        [ProtoMember(3)]
        private string BinaryVoxelChunk_LOD1_File;

        [ProtoMember(4)]
        private string BinaryVoxelChunk_LOD2_File;

        [ProtoMember(5)]
        private int MaxCacheEntries = 10;

        [ProtoMember(6)]
        public int ChunkSide = 1;

        Queue<int> ChunkCacheTracker { get; set; }
        Dictionary<int, BinaryVoxelChunk> ChunkCache { get; set; }

        //Allow runtime deformation of size to allow for a single set of voxel data to represent standard shapes
        public Vector3 Scale { get; set; } = Vector3.One;

        //Load this data from a file generated by the content pipeline, alternatively, allow runtime specification of the data
        public VoxelObject() { }

        public VoxelObject(BinaryVoxelTree c, Dictionary<int, BinaryVoxelChunk> chunks)
        {
            Center = c;
            ChunkCache = chunks;

            BinaryVoxelChunk_LOD0_File =
            BinaryVoxelChunk_LOD1_File =
            BinaryVoxelChunk_LOD2_File = null;
        }

        public static VoxelObject Load(string file)
        {
            VoxelObject e = null;
            using (FileStream a = File.OpenRead(file))
                e = Serializer.Deserialize<VoxelObject>(a);

            e.ChunkCacheTracker = new Queue<int>(10);
            e.ChunkCache = new Dictionary<int, BinaryVoxelChunk>();

            return e;
        }

        public static void Save(string file, VoxelObject v)
        {
            using (FileStream a = File.Create(file)) Serializer.Serialize(a, v);
        }
    }
}
